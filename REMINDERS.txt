Good resources:
https://docs.oracle.com/javaee/5/tutorial/doc/bnaff.html (In-depth tutorial)
https://stackoverflow.com/questions/7213541/what-is-java-servlet (What is a servlet, multiple good answers)
https://www.tutorialspoint.com/servlets/ (Servlet tutorials)
https://github.com/ajanata/PretendYoureXyzzy (Cards against humanity clone)
https://github.com/ajanata/PretendYoureXyzzy/blob/ed08e371978529db8a908e266dc1a8add1d37967/src/main/java/net/socialgamer/cah/data/Game.java#L67 (Game class FSM)

Notes (might have errors so double check):
Apache Tomcat is Java Servlet/Web container.
A servlet is a class that manages a specific HTTP request, and sends the intended response back
You code the servlets, and Apache Tomcat uses them when it runs as a web server.

Basically, Tomcat is a program that runs on a server that waits for HTTP requests and calls a servlet that handles the request, which
tells Tomcat what to send back (HTML file, images, etc.) to the client that sent the request, and Tomcat does that.


Important Servlet Methods:

init() is called once at the start of server initialization. You can use servlet constructor to initialize variables, but it is considered good practice to use init() instead. Source: https://stackoverflow.com/questions/2381976/why-can-not-we-call-servlet-constructor-instead-of-init-method-to-initialize-the
destroy() (acts like a destructor to close resources servlet uses)

doGet() is called (by tomcat) whenever the browser sends a GET request to the specified servlet path
- "GET requests a representation of the specified resource. 
Note that GET should not be used for operations that cause side-effects,
such as using it for taking actions in web applications."

doPost() is called (by tomcat) whenever the browser sends a POST request to the specified servlet path
- "POST submits data to be processed (e.g., from an HTML form) to the identified resource. 
The data is included in the body of the request. 
This may result in the creation of a new resource or the updates of existing resources or both."
doDelete() and doPut()

Also, servlets can call other servlets in those functions (through requestdispatchers and forward)

Also, servlets are not unique for each client. For each type of servlet, there is a single instance running that all client requests (that are directed at that type of servlet) go through.
Good picture explaining this^: https://www.tutorialspoint.com/servlets/images/servlet-lifecycle.jpg


Filters:
Filters are objects (used by Tomcat) which requests pass through on their way to a servlet to be handled.
Responses also can pass through filters on their way out from a servlet, and be changed/logged by them.
Uses
-Logging
-etc.


Listeners:
Servlet Listener is used for listening to events in a web containers, 
such as when you create a session, or place an attribute in an session,
to subscribe to these events you can configure listener in web.xml, 
for example HttpSessionListener.


Information flow:
Simplified step-by-step process of browser/server communication
1. Type in url in web browser and press enter
1. Web browser sends HTTP request string to server
3. Tomcat has polling loop listening, gets request, parses it into class, does error handling, etc.
4. Tomcat then calls a servlet class (that you coded) that handles that request
5. Servlet runs, generates a response, and gives Tomcat that response.
6. Tomcat sends that response back to the client.

|Web browser| <-HTTP-> |Tomcat| <-Calls through code-> |Servlets| <-Calls through code-> |MongoDB code| <-HTTP?-> |MongoDB cloud|

we code                                                  this^                              and this^ 

File structure:
Servlets, java util/tools, and web app java code go in Java Resources/src
Client-side code (CSS, HTML, JS) goes into WebContent/WEB-INF (I think) (except for index.html)
Client-side resources (Images and XMLs) go into WEB-INF also

Note: https://crunchify.com/eclipse-missing-web-xml-file-how-can-i-create-web-xml-in-eclipse/#:~:text=Eclipse%20allows%20you%20to%20NOT,to%20de%2Demphasize%20deployment%20descriptors.&text=If%20you%20are%20trying%20to,to%20avoid%20creating%20a%20web.
Eclipse doesn't use a web.xml file, you just specify the paths of servlets through annotations

Managing guest users vs registered users:
Whenever a client sends a POST request to do an action, or access a page, for registered users, we have to check whether or not that client is a registered user.
For the servlet that manages the request, it must check for a username and password in that POST request.
But HTTP requests are stateless, the server doesn't cache the request that was sent when the end user entered their login info.
And we only want the end user to enter their username and password once.
Here are some ways to store their username and password between page refreshes/requests: https://www.tutorialspoint.com/servlets/servlets-session-tracking.htm


Room system plans:
Maybe just make a room servlet that acts on post commands. There is a post request for creating a room, joining one (with room code), leaving one, etc. starting game.
Also, have a game servlet


Constants file and attributes:
Should have constant file contains classes with static strings to use to get and set attributes, to prevent errors that would arise if I misspelled an attribute name.
https://github.com/ajanata/PretendYoureXyzzy/blob/ed08e371978529db8a908e266dc1a8add1d37967/src/main/java/net/socialgamer/cah/Constants.java#L891

How Pretend You're Xyzzy does client server communication through AJAX (from looking at the code and guessing):
(Have to use constant file to somehow make the strings consistent with each other)
Each AJAX request is required to have an OP (operation) field. This field can contain any string from a predefined set in a constants file/class (ENUM list?) (In the xyzzy repo they call it AjaxOperation).
The server looks at the OP field when it first gets the request, and then checks the request for other fields that are needed to process the operation.

//structure of request (have to convert to json to send i think though)
type AjaxRequest struct {
	Serial int `json:"s"`
	Op string `json:"o"`
	Wall bool `json:"wall"`
	PersistentId string `json:"pid"`
	Emote bool `json:"me"`
	CardcastId string `json:"cci"`
	GameId int `json:"gid"`
	GameOptions GameOptionData `json:"go"`
	Message string `json:"m"`
	Nickname string `json:"n"`
	Password string `json:"pw"`
	CardId int `json:"cid"`
	IdCode string `json:"idc"`
}

Op field is assigned using a enum from set of consts (AjaxOperation)
Key value for each field for json is defined in a set of consts (AjaxRequests)
Consts for other fields too (Cardcast, etc.)

ajax.Builder(op) starts building the dictionary/json, initially with only the op term defined (as it is the most important one)

Description for builder methods:
 * Builder for ajax requests. This contains methods to add every possible parameter to an ajax
 * request, even if it doesn't make sense for the operation code.

Is there a better practice than having only one type of "god" request that can contain everything.
Maybe factory methods to encapsulate the building (and keep in valid state the request) of OP requests.
Or maybe different servlets for different OP requests/actions with each request directed to its own type of servlet (Is this bad practice?)

AJAX request timeline:
1. AJAX constructs request (json?) clientside based on client input and sends it
2. AjaxServlet receives request, checks if valid (ex. has OP defined)
3. AjaxServlet looks at request OP, and calls an instance specific subclass of the Handler class (what is even a handler)
(by using a static hashmap init at startup that links each OP with a specific subclass of Handler)

4. Handler subclass looks at requests, does some stuff with the internal model of the webserver/webapp, then generates response
5. Servlet gets response back from handler, sends back to client

Room/lobby system plans cont.:
In the pyx repo, the CreateGameHandler has a reference to an instance of a gamemanager object.
How, and where, is that instance constructed? Tomcat manages flow of control. Can't create instance in main.

I think each handler instance is a singleton, created at startup
What I need, is a class or something that stores a list of all singletons, which can be accessed by a function getInstance(type classtype)
If I make the handlers singletons, then I could instantiate gamemanager (and other shared resources) in one of their static constructors.
But if two or more singletons require a single resource, do I need something to inject it into the constructors of the handlers.
Something that runs at startup like this and does these in order:
> Create all necessary resources
> Create handlers with resources in the constructors

Or maybe the resources can also be singletons too, so whenever something calls getInstance() of SomethingHandler, and SomethingHandler(GameManager gm) constructor takes a gamemanager,
what I can do is make "instance = new SomethingHandler(GameManager.getInstance())" and instantiate gamemanager whenever it is first needed


On thread safety:
Servlets are not thread safe, 
gotta make singleton classes threadsafe to prevent race conditions, 
don't want to unnecessarily use synchronized and locks because that causes bottlenecks and slows down server.


Options for website structure:
Requirements
- Want gameplay to update client smoothly, no page refreshes, which means need to use AJAX

Option 1:
Have whole thing be a single page application. See: https://en.wikipedia.org/wiki/Single-page_application

Option 2:
Login page (static) -> Game page (Dynamic/AJAX) (Room/lobby join, lobby, gameplay)

Option 3:
Login page (static) -> Room join page/homepage (static) -> Lobby (Dynamic/AJAX) -> Game (Dynamic/AJAX)

1 is closest to SPA, 3 is closest to MPA

More pages would add some complexity. As we would still need AJAX, so it would be a mix of static and dynamic content.
Would also need multiple servlets for each page.

One single page application could be good. Need only one servlet for AJAX. 
Servlet would just parse and delegate requests to different types of handler classes, which would generate appropriate responses.
Or maybe we need to look into WebSockets, another way of client/server communication without reloading page


Updating all players screens on move/game action/state change:
AJAX is a request response communication protocol. Server can only give client data if client requests.
So how can we send updated game/state information to clients when someone else does a move (sends a POST/AJAX request).
A: Long polling. See (https://www.pubnub.com/blog/http-long-polling/)
The client sends a recurring request to the server at initialization requesting new information (i.e. a game state change)
The server holds the request (doesnt answer it) until an event happens (state change)
Then the server returns the state change in the response.
The client grabs the response, handles it, then long polls again.
This way, the server has some control over sending the client information whenever it wants.
The server doesn't have to wait for the client to request, because the client is always requesting.
This is how we can update all players screens whenever one player makes a move.
Or we can use websockets which allows server to send data without request from the client. (More like traditional peer to peer communication)





